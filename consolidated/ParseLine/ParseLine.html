<!DOCTYPE html>
<html>
<head>
<title>ParseLine</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */
/* Revision: modified for personal taste by RhoSigma */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Verdana, Helvetica, arial, freesans, clean, sans-serif;
  font-size: 18px;
  line-height: 1.6;
  color: #aaa5a5;
  background-color: #181818;
  padding: 20px;
  min-width: 720px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

strong em {
  filter: brightness(100%);
}

strong {
  filter: brightness(111%);
}

em {
  filter: brightness(122%);
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h4, h5, h6 {
  font-weight: normal;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 36px;
  color: #ee4000;
}

h2 {
  font-size: 32px;
  border-bottom: 1px solid #ccc;
  color: #ee4000;
}

h3 {
  font-size: 30px;
  color: #ee4000;
}

h4 {
  font-size: 18px;
  color: #007df0;
}

h5 {
  font-size: 18px;
  color: #66cd00;
}

h6 {
  font-size: 18px;
  color: #cd3278;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #3232e0;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ol {
  color: #fff68f;
  padding-left: 30px;
}

ul {
  color: #aaa5a5;
  padding-left: 30px;
}

ul li > :first-child,
ol li > :first-child,
ul li ul:first-of-type,
ol li ol:first-of-type,
ul li ol:first-of-type,
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 18px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 1px 1px;
  white-space: nowrap;
  border: 1px solid #fff68f;
  background-color: #404040;
  color: #20b2aa;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #404040;
  border: 2px solid #fff68f;
  font-size: 18px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  color: #20b2aa;
  border-radius: 5px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #cd0000;
  padding: 0 15px;
  color: #cdad00;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #008b45;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<hr />
<h2>ParseLine <em>(function)</em></h2>
<p>Does parse the given input line and break the line up into its individual
words or components according to the given separators and quoting chars.</p>
<p>Any kind and number of the given separator chars will split the components
unless they appear in quoted sections. Parts of the line enclosed by the
given quotation char(s) will be handled as one word or component. For more
specific information see the <strong><em>PARSING RULES</em></strong> below.</p>
<hr />
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><strong><em>SYNTAX:</em></strong></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<pre><code>ub&amp; = ParseLine&amp; (inpLine$, sepChars$, quoChars$, outArray$(), minUB&amp;)
</code></pre>

</blockquote>
<hr />
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><strong><em>INPUTS:</em></strong></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h4>inpLine$ <em>(STRING)</em></h4>
<ul>
<li>The input line which you want to process. This may in fact be any
sequence of chars including control chars and zeros.</li>
</ul>
<h4>sepChars$ <em>(STRING)</em></h4>
<ul>
<li>
This string may contain up to 5 different chars, which shall serve as
separators, such as tabs or spaces. More chars following the 5th one will
be ignored.
<ul>
<li>If left empty, then only the given quoting char(s) will split the
components.</li>
</ul>
</li>
</ul>
<h4>quoChars$ <em>(STRING)</em></h4>
<ul>
<li>
This string may contain up to 2 different chars, which shall serve as
quotation marks. More chars following the 2nd one will be ignored.
<ul>
<li>If left empty, then the regular quotation mark (<strong>&quot;</strong>) is used by default.</li>
<li>If only one char is given, then it simply replaces the regular quotation
mark (<strong>&quot;</strong>).</li>
<li>
If two chars are given, then the first one serves as opening quote mark
and the second one as matching closing quote mark.
<ul>
<li>If both chars are identical, then it behaves like only one char again.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>outArray$() <em>(STRING array)</em></h4>
<ul>
<li>This must be a 1-dimensional REDIMed (dynamic) <em>STRING</em> array of at
least one element, in which the individual components will be stored.
The array will be internally adjusted as needed for the number of
components found in the input line. It will always keep the lower
bound, but will raise or reduce the upper bound as needed.</li>
</ul>
<h4>minUB&amp; <em>(LONG)</em></h4>
<ul>
<li>
Should be either zero or the minimum upper bound, which the output
array shall have after the call. This can be used, if you expect a fix
number of components.
<ul>
<li>If the input line has not enough components, then the unused array
elements remain empty.</li>
<li>Note that the array may still grow bigger, if the line has more
components than expected.</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><strong><em>RESULT:</em></strong></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h4>ub&amp; <em>(LONG)</em></h4>
<ul>
<li>The final upper bound of the output array after parsing. It will
be negative (-1) if there was nothing to parse (ie. the input line
was either empty or consisted of separators only), the given array
remains unchanged in that case.</li>
</ul>
</blockquote>
<hr />
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><strong><em>PARSING RULES:</em></strong></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h6><strong>Note that a char cannot be a separator and a quoting char at the same time, if required you've to workaround that by performing several parsing stages !!</strong></h6>
<ul>
<li>Any separators will split up the words or components as usual.</li>
<li>Opening a quotation will also split (even without leading separators),
ie. it will finish the currently processed (unquoted) component and begins
the quoted one.</li>
<li>Closing a quotation (even without trailing separators) will finish the
current (quoted) component.</li>
<li>Quoted components may be empty (&quot;&quot;) and produce an empty array entry
in that case.</li>
<li>An open quoted component with no closing mark in the remaining input line
will be closed at the end of line (EOL), ie. the complete remaining line is
taken (as is) in one quoted component.</li>
<li>With respect to the latter two points, opening a quotation with the very
last char of the input line will produce an additional empty array
entry (as it is, in fact, an empty quoted component closed by EOL).</li>
</ul>
<h6><em>Quoting rules: (one char mode)</em></h6>
<ul>
<li>Very simple and logic, the 1st occurrence of the given quoting char opens
a quote, the 2nd occurrence does close it, the 3rd will open the next quote,
the 4th does close it again and so on.</li>
</ul>
<h6><em>Quoting rules: (two chars mode)</em></h6>
<ul>
<li>The occurrence of the opening quote mark (1st given char) does open a quote,
further only a matching occurrence of the closing quote mark (2nd char)
does close the (quoted) component.</li>
<li>
Nesting of several quotes is not supported, hence every quote must be closed,
before another one may be opened, ie:
<ul>
<li>Further open/close markers inside a quote will be handled as literal text
until the internal counter recognizes a matching close marker.</li>
<li>Also close markers outside a quote will be handled as literal text as well.</li>
</ul>
</li>
</ul>
</blockquote>
<hr />

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
